<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/grupo8/fullsound/data/local/BeatDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/grupo8/fullsound/data/local/BeatDao.kt" />
              <option name="originalContent" value="package com.grupo8.fullsound.data.local&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Insert&#10;import androidx.room.OnConflictStrategy&#10;import androidx.room.Query&#10;import com.grupo8.fullsound.data.models.Beat&#10;&#10;@Dao&#10;interface BeatDao {&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertBeat(beat: Beat)&#10;&#10;    @Query(&quot;SELECT * FROM beats WHERE id = :beatId&quot;)&#10;    suspend fun getBeatById(beatId: String): Beat?&#10;&#10;    @Query(&quot;SELECT * FROM beats&quot;)&#10;    suspend fun getAllBeats(): List&lt;Beat&gt;&#10;}" />
              <option name="updatedContent" value="package com.grupo8.fullsound.data.local&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Delete&#10;import androidx.room.Insert&#10;import androidx.room.OnConflictStrategy&#10;import androidx.room.Query&#10;import androidx.room.Update&#10;import com.grupo8.fullsound.data.models.Beat&#10;&#10;@Dao&#10;interface BeatDao {&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertBeat(beat: Beat)&#10;&#10;    @Query(&quot;SELECT * FROM beats WHERE id = :beatId&quot;)&#10;    suspend fun getBeatById(beatId: String): Beat?&#10;&#10;    @Query(&quot;SELECT * FROM beats&quot;)&#10;    suspend fun getAllBeats(): List&lt;Beat&gt;&#10;&#10;    @Update&#10;    suspend fun updateBeat(beat: Beat)&#10;&#10;    @Delete&#10;    suspend fun deleteBeat(beat: Beat)&#10;&#10;    @Query(&quot;DELETE FROM beats WHERE id = :beatId&quot;)&#10;    suspend fun deleteBeatById(beatId: String)&#10;&#10;    @Query(&quot;DELETE FROM beats&quot;)&#10;    suspend fun deleteAllBeats()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/grupo8/fullsound/data/local/UserDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/grupo8/fullsound/data/local/UserDao.kt" />
              <option name="originalContent" value="package com.grupo8.fullsound.data.local&#10;&#10;import androidx.room.*&#10;import com.grupo8.fullsound.data.models.User&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface UserDao {&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertUser(user: User)&#10;&#10;    @Query(&quot;SELECT * FROM users WHERE email = :email AND password = :password&quot;)&#10;    suspend fun getUser(email: String, password: String): User?&#10;&#10;    @Query(&quot;SELECT * FROM users WHERE id = :userId&quot;)&#10;    suspend fun getUserById(userId: String): User?&#10;&#10;    @Query(&quot;SELECT * FROM users WHERE email = :email&quot;)&#10;    suspend fun getUserByEmail(email: String): User?&#10;}" />
              <option name="updatedContent" value="package com.grupo8.fullsound.data.local&#10;&#10;import androidx.room.*&#10;import com.grupo8.fullsound.data.models.User&#10;&#10;@Dao&#10;interface UserDao {&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertUser(user: User)&#10;&#10;    @Query(&quot;SELECT * FROM users WHERE email = :email AND password = :password&quot;)&#10;    suspend fun getUser(email: String, password: String): User?&#10;&#10;    @Query(&quot;SELECT * FROM users WHERE id = :userId&quot;)&#10;    suspend fun getUserById(userId: String): User?&#10;&#10;    @Query(&quot;SELECT * FROM users WHERE email = :email&quot;)&#10;    suspend fun getUserByEmail(email: String): User?&#10;&#10;    @Update&#10;    suspend fun updateUser(user: User)&#10;&#10;    @Delete&#10;    suspend fun deleteUser(user: User)&#10;&#10;    @Query(&quot;DELETE FROM users WHERE id = :userId&quot;)&#10;    suspend fun deleteUserById(userId: String)&#10;&#10;    @Query(&quot;SELECT * FROM users&quot;)&#10;    suspend fun getAllUsers(): List&lt;User&gt;&#10;&#10;    @Query(&quot;DELETE FROM users&quot;)&#10;    suspend fun deleteAllUsers()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/grupo8/fullsound/data/repositories/UserRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/grupo8/fullsound/data/repositories/UserRepository.kt" />
              <option name="originalContent" value="package com.grupo8.fullsound.data.repositories&#10;&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import com.grupo8.fullsound.data.local.UserDao&#10;import com.grupo8.fullsound.data.models.User&#10;import com.grupo8.fullsound.utils.Resource&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import java.util.UUID&#10;&#10;class UserRepository(private val userDao: UserDao) {&#10;&#10;    private val _loginResult = MutableLiveData&lt;Resource&lt;User&gt;&gt;()&#10;    val loginResult: LiveData&lt;Resource&lt;User&gt;&gt; = _loginResult&#10;&#10;    private val _registerResult = MutableLiveData&lt;Resource&lt;User&gt;&gt;()&#10;    val registerResult: LiveData&lt;Resource&lt;User&gt;&gt; = _registerResult&#10;&#10;    fun login(email: String, password: String) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            _loginResult.postValue(Resource.Loading())&#10;            try {&#10;                val user = userDao.getUser(email, password)&#10;                if (user != null) {&#10;                    _loginResult.postValue(Resource.Success(user))&#10;                } else {&#10;                    _loginResult.postValue(Resource.Error(&quot;Credenciales inválidas&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                _loginResult.postValue(Resource.Error(&quot;Error de conexión: ${e.message}&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    fun register(email: String, password: String, name: String) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            _registerResult.postValue(Resource.Loading())&#10;            try {&#10;                // Verificar si el usuario ya existe&#10;                val existingUser = userDao.getUserByEmail(email)&#10;                if (existingUser != null) {&#10;                    _registerResult.postValue(Resource.Error(&quot;El usuario ya existe&quot;))&#10;                    return@launch&#10;                }&#10;&#10;                // Crear nuevo usuario&#10;                val newUser = User(&#10;                    id = UUID.randomUUID().toString(),&#10;                    email = email,&#10;                    password = password,&#10;                    name = name,&#10;                    createdAt = System.currentTimeMillis()&#10;                )&#10;                userDao.insertUser(newUser)&#10;                _registerResult.postValue(Resource.Success(newUser))&#10;            } catch (e: Exception) {&#10;                _registerResult.postValue(Resource.Error(&quot;Error al registrar usuario: ${e.message}&quot;))&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.grupo8.fullsound.data.repositories&#10;&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import com.grupo8.fullsound.data.local.UserDao&#10;import com.grupo8.fullsound.data.models.User&#10;import com.grupo8.fullsound.utils.Resource&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import java.util.UUID&#10;&#10;class UserRepository(private val userDao: UserDao) {&#10;&#10;    private val _loginResult = MutableLiveData&lt;Resource&lt;User&gt;&gt;()&#10;    val loginResult: LiveData&lt;Resource&lt;User&gt;&gt; = _loginResult&#10;&#10;    private val _registerResult = MutableLiveData&lt;Resource&lt;User&gt;&gt;()&#10;    val registerResult: LiveData&lt;Resource&lt;User&gt;&gt; = _registerResult&#10;&#10;    private val _userResult = MutableLiveData&lt;Resource&lt;User&gt;&gt;()&#10;    val userResult: LiveData&lt;Resource&lt;User&gt;&gt; = _userResult&#10;&#10;    private val _usersResult = MutableLiveData&lt;Resource&lt;List&lt;User&gt;&gt;&gt;()&#10;    val usersResult: LiveData&lt;Resource&lt;List&lt;User&gt;&gt;&gt; = _usersResult&#10;&#10;    private val _deleteResult = MutableLiveData&lt;Resource&lt;String&gt;&gt;()&#10;    val deleteResult: LiveData&lt;Resource&lt;String&gt;&gt; = _deleteResult&#10;&#10;    fun login(email: String, password: String) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            _loginResult.postValue(Resource.Loading())&#10;            try {&#10;                val user = userDao.getUser(email, password)&#10;                if (user != null) {&#10;                    _loginResult.postValue(Resource.Success(user))&#10;                } else {&#10;                    _loginResult.postValue(Resource.Error(&quot;Credenciales inválidas&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                _loginResult.postValue(Resource.Error(&quot;Error de conexión: ${e.message}&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    fun register(email: String, password: String, name: String) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            _registerResult.postValue(Resource.Loading())&#10;            try {&#10;                // Verificar si el usuario ya existe&#10;                val existingUser = userDao.getUserByEmail(email)&#10;                if (existingUser != null) {&#10;                    _registerResult.postValue(Resource.Error(&quot;El usuario ya existe&quot;))&#10;                    return@launch&#10;                }&#10;&#10;                // Crear nuevo usuario&#10;                val newUser = User(&#10;                    id = UUID.randomUUID().toString(),&#10;                    email = email,&#10;                    password = password,&#10;                    name = name,&#10;                    createdAt = System.currentTimeMillis()&#10;                )&#10;                userDao.insertUser(newUser)&#10;                _registerResult.postValue(Resource.Success(newUser))&#10;            } catch (e: Exception) {&#10;                _registerResult.postValue(Resource.Error(&quot;Error al registrar usuario: ${e.message}&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    // READ&#10;    fun getUserById(userId: String) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            _userResult.postValue(Resource.Loading())&#10;            try {&#10;                val user = userDao.getUserById(userId)&#10;                if (user != null) {&#10;                    _userResult.postValue(Resource.Success(user))&#10;                } else {&#10;                    _userResult.postValue(Resource.Error(&quot;Usuario no encontrado&quot;))&#10;                }&#10;            } catch (e: Exception) {&#10;                _userResult.postValue(Resource.Error(&quot;Error al obtener usuario: ${e.message}&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getAllUsers() {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            _usersResult.postValue(Resource.Loading())&#10;            try {&#10;                val users = userDao.getAllUsers()&#10;                _usersResult.postValue(Resource.Success(users))&#10;            } catch (e: Exception) {&#10;                _usersResult.postValue(Resource.Error(&quot;Error al obtener usuarios: ${e.message}&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    // UPDATE&#10;    fun updateUser(user: User) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            _userResult.postValue(Resource.Loading())&#10;            try {&#10;                userDao.updateUser(user)&#10;                _userResult.postValue(Resource.Success(user))&#10;            } catch (e: Exception) {&#10;                _userResult.postValue(Resource.Error(&quot;Error al actualizar usuario: ${e.message}&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    // DELETE&#10;    fun deleteUser(user: User) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            _deleteResult.postValue(Resource.Loading())&#10;            try {&#10;                userDao.deleteUser(user)&#10;                _deleteResult.postValue(Resource.Success(&quot;Usuario eliminado exitosamente&quot;))&#10;            } catch (e: Exception) {&#10;                _deleteResult.postValue(Resource.Error(&quot;Error al eliminar usuario: ${e.message}&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteUserById(userId: String) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            _deleteResult.postValue(Resource.Loading())&#10;            try {&#10;                userDao.deleteUserById(userId)&#10;                _deleteResult.postValue(Resource.Success(&quot;Usuario eliminado exitosamente&quot;))&#10;            } catch (e: Exception) {&#10;                _deleteResult.postValue(Resource.Error(&quot;Error al eliminar usuario: ${e.message}&quot;))&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/grupo8/fullsound/ui/beats/BeatsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/grupo8/fullsound/ui/beats/BeatsFragment.kt" />
              <option name="originalContent" value="package com.grupo8.fullsound.ui.beats&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import androidx.fragment.app.Fragment&#10;import com.grupo8.fullsound.databinding.FragmentBeatsBinding&#10;&#10;class BeatsFragment : Fragment() {&#10;&#10;    private var _binding: FragmentBeatsBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentBeatsBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.grupo8.fullsound.ui.beats&#13;&#10;&#13;&#10;import android.os.Bundle&#13;&#10;import android.view.LayoutInflater&#13;&#10;import android.view.View&#13;&#10;import android.view.ViewGroup&#13;&#10;import androidx.fragment.app.Fragment&#13;&#10;import androidx.fragment.app.viewModels&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.ViewModelProvider&#13;&#10;import com.grupo8.fullsound.data.local.AppDatabase&#13;&#10;import com.grupo8.fullsound.data.repositories.BeatRepository&#13;&#10;import com.grupo8.fullsound.databinding.FragmentBeatsBinding&#13;&#10;import com.grupo8.fullsound.utils.Resource&#13;&#10;&#13;&#10;class BeatsFragment : Fragment() {&#13;&#10;&#13;&#10;    private var _binding: FragmentBeatsBinding? = null&#13;&#10;    private val binding get() = _binding!!&#13;&#10;    &#13;&#10;    private val viewModel: BeatsViewModel by viewModels {&#13;&#10;        val database = AppDatabase.getInstance(requireContext())&#13;&#10;        val beatRepository = BeatRepository(database.beatDao())&#13;&#10;        BeatsViewModelFactory(beatRepository)&#13;&#10;    }&#13;&#10;&#13;&#10;    override fun onCreateView(&#13;&#10;        inflater: LayoutInflater, container: ViewGroup?,&#13;&#10;        savedInstanceState: Bundle?&#13;&#10;    ): View {&#13;&#10;        _binding = FragmentBeatsBinding.inflate(inflater, container, false)&#13;&#10;        return binding.root&#13;&#10;    }&#13;&#10;&#13;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#13;&#10;        super.onViewCreated(view, savedInstanceState)&#13;&#10;        setupObservers()&#13;&#10;        &#13;&#10;        // Cargar todos los beats al iniciar&#13;&#10;        viewModel.getAllBeats()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun setupObservers() {&#13;&#10;        // Observar lista de beats&#13;&#10;        viewModel.beatsResult.observe(viewLifecycleOwner) { result -&gt;&#13;&#10;            when (result) {&#13;&#10;                is Resource.Loading -&gt; {&#13;&#10;                    // Mostrar cargando&#13;&#10;                }&#13;&#10;                is Resource.Success -&gt; {&#13;&#10;                    val beats = result.data&#13;&#10;                    // Actualizar UI con la lista de beats&#13;&#10;                    binding.beatsTitle.text = &quot;Total de Beats: ${beats?.size ?: 0}&quot;&#13;&#10;                }&#13;&#10;                is Resource.Error -&gt; {&#13;&#10;                    // Mostrar error&#13;&#10;                    showMessage(result.message ?: &quot;Error al cargar beats&quot;)&#13;&#10;                }&#13;&#10;                else -&gt; {}&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        // Observar resultado de operaciones individuales&#13;&#10;        viewModel.beatResult.observe(viewLifecycleOwner) { result -&gt;&#13;&#10;            when (result) {&#13;&#10;                is Resource.Success -&gt; {&#13;&#10;                    showMessage(&quot;Operación exitosa&quot;)&#13;&#10;                }&#13;&#10;                is Resource.Error -&gt; {&#13;&#10;                    showMessage(result.message ?: &quot;Error en operación&quot;)&#13;&#10;                }&#13;&#10;                else -&gt; {}&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        // Observar resultado de eliminación&#13;&#10;        viewModel.deleteResult.observe(viewLifecycleOwner) { result -&gt;&#13;&#10;            when (result) {&#13;&#10;                is Resource.Success -&gt; {&#13;&#10;                    showMessage(result.data ?: &quot;Eliminado exitosamente&quot;)&#13;&#10;                    // Recargar la lista&#13;&#10;                    viewModel.getAllBeats()&#13;&#10;                }&#13;&#10;                is Resource.Error -&gt; {&#13;&#10;                    showMessage(result.message ?: &quot;Error al eliminar&quot;)&#13;&#10;                }&#13;&#10;                else -&gt; {}&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun showMessage(message: String) {&#13;&#10;        android.widget.Toast.makeText(requireContext(), message, android.widget.Toast.LENGTH_SHORT).show()&#13;&#10;    }&#13;&#10;&#13;&#10;    override fun onDestroyView() {&#13;&#10;        super.onDestroyView()&#13;&#10;        _binding = null&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;class BeatsViewModelFactory(private val beatRepository: BeatRepository) : ViewModelProvider.Factory {&#13;&#10;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#13;&#10;        if (modelClass.isAssignableFrom(BeatsViewModel::class.java)) {&#13;&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#13;&#10;            return BeatsViewModel(beatRepository) as T&#13;&#10;        }&#13;&#10;        throw IllegalArgumentException(&quot;Unknown ViewModel class&quot;)&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/grupo8/fullsound/ui/beats/BeatsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/grupo8/fullsound/ui/beats/BeatsViewModel.kt" />
              <option name="updatedContent" value="package com.grupo8.fullsound.ui.beats&#10;&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.ViewModel&#10;import com.grupo8.fullsound.data.models.Beat&#10;import com.grupo8.fullsound.data.repositories.BeatRepository&#10;import com.grupo8.fullsound.utils.Resource&#10;&#10;class BeatsViewModel(private val beatRepository: BeatRepository) : ViewModel() {&#10;&#10;    val beatsResult: LiveData&lt;Resource&lt;List&lt;Beat&gt;&gt;&gt; = beatRepository.beatsResult&#10;    val beatResult: LiveData&lt;Resource&lt;Beat&gt;&gt; = beatRepository.beatResult&#10;    val deleteResult: LiveData&lt;Resource&lt;String&gt;&gt; = beatRepository.deleteResult&#10;&#10;    // CREATE&#10;    fun insertBeat(beat: Beat) {&#10;        beatRepository.insertBeat(beat)&#10;    }&#10;&#10;    // READ&#10;    fun getAllBeats() {&#10;        beatRepository.getAllBeats()&#10;    }&#10;&#10;    fun getBeatById(beatId: String) {&#10;        beatRepository.getBeatById(beatId)&#10;    }&#10;&#10;    // UPDATE&#10;    fun updateBeat(beat: Beat) {&#10;        beatRepository.updateBeat(beat)&#10;    }&#10;&#10;    // DELETE&#10;    fun deleteBeat(beat: Beat) {&#10;        beatRepository.deleteBeat(beat)&#10;    }&#10;&#10;    fun deleteBeatById(beatId: String) {&#10;        beatRepository.deleteBeatById(beatId)&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>